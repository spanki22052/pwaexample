{"ast":null,"code":"import { openDB } from \"idb\";\nconst DB_NAME = \"PhotoPWA\";\nconst DB_VERSION = 1;\nconst STORE_NAME = \"photos\";\nclass PhotoService {\n  constructor() {\n    this.db = null;\n    this.initDB();\n  }\n  async initDB() {\n    try {\n      this.db = await openDB(DB_NAME, DB_VERSION, {\n        upgrade(db) {\n          if (!db.objectStoreNames.contains(STORE_NAME)) {\n            db.createObjectStore(STORE_NAME, {\n              keyPath: \"id\"\n            });\n          }\n        }\n      });\n    } catch (error) {\n      console.error(\"Ошибка инициализации IndexedDB:\", error);\n    }\n  }\n  async savePhoto(photoData) {\n    try {\n      if (!this.db) await this.initDB();\n\n      // Конвертируем File в ArrayBuffer для хранения\n      const arrayBuffer = await photoData.file.arrayBuffer();\n      const photoToSave = {\n        ...photoData,\n        fileData: arrayBuffer,\n        fileType: photoData.file.type,\n        fileName: photoData.file.name\n      };\n\n      // Удаляем оригинальный File объект\n      delete photoToSave.file;\n      await this.db.put(STORE_NAME, photoToSave);\n      return photoToSave;\n    } catch (error) {\n      console.error(\"Ошибка сохранения фотографии:\", error);\n      throw error;\n    }\n  }\n  async getAllPhotos() {\n    try {\n      if (!this.db) await this.initDB();\n      const photos = await this.db.getAll(STORE_NAME);\n\n      // Восстанавливаем File объекты из ArrayBuffer\n      return photos.map(photo => {\n        if (photo.fileData) {\n          const file = new File([photo.fileData], photo.fileName, {\n            type: photo.fileType\n          });\n          return {\n            ...photo,\n            file: file\n          };\n        }\n        return photo;\n      });\n    } catch (error) {\n      console.error(\"Ошибка загрузки фотографий:\", error);\n      return [];\n    }\n  }\n  async updatePhotoStatus(photoId, status, error = null) {\n    try {\n      if (!this.db) {\n        await this.initDB();\n      }\n      const photo = await this.db.get(STORE_NAME, photoId);\n      if (photo) {\n        photo.status = status;\n        if (error) {\n          photo.error = error;\n        }\n        await this.db.put(STORE_NAME, photo);\n      }\n    } catch (error) {\n      console.error(\"Ошибка обновления статуса фотографии:\", error);\n    }\n  }\n  async deletePhoto(photoId) {\n    try {\n      if (!this.db) {\n        await this.initDB();\n      }\n      await this.db.delete(STORE_NAME, photoId);\n    } catch (error) {\n      console.error(\"Ошибка удаления фотографии:\", error);\n    }\n  }\n  async uploadPhoto(photoData) {\n    try {\n      // Обновляем статус на \"загрузка\"\n      await this.updatePhotoStatus(photoData.id, \"uploading\");\n\n      // Создаем FormData для отправки файла\n      const formData = new FormData();\n      formData.append(\"photo\", photoData.file);\n      formData.append(\"id\", photoData.id);\n      formData.append(\"name\", photoData.name);\n      formData.append(\"createdAt\", photoData.createdAt);\n\n      // Отправляем на локальный сервер\n      // Если сервер не запущен, используем httpbin.org для демонстрации\n      let apiUrl = \"http://localhost:3001/api/upload\";\n\n      // Проверяем, доступен ли локальный сервер\n      try {\n        await fetch(\"http://localhost:3001/api/files\", {\n          method: \"HEAD\"\n        });\n      } catch {\n        // Если локальный сервер недоступен, используем httpbin\n        apiUrl = \"https://httpbin.org/post\";\n      }\n      const response = await fetch(apiUrl, {\n        method: \"POST\",\n        body: formData\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const result = await response.json();\n\n      // Обновляем статус в базе данных\n      await this.updatePhotoStatus(photoData.id, \"uploaded\");\n      return {\n        id: photoData.id,\n        url: result.url || `https://example.com/photos/${photoData.id}.jpg`,\n        uploadedAt: new Date().toISOString(),\n        serverResponse: result\n      };\n    } catch (error) {\n      console.error(\"Ошибка загрузки фотографии:\", error);\n\n      // Обновляем статус на ошибку\n      await this.updatePhotoStatus(photoData.id, \"error\", error.message);\n      throw error;\n    }\n  }\n\n  // Метод для очистки старых фотографий (опционально)\n  async cleanupOldPhotos(daysOld = 30) {\n    try {\n      if (!this.db) {\n        await this.initDB();\n      }\n      const cutoffDate = new Date();\n      cutoffDate.setDate(cutoffDate.getDate() - daysOld);\n      const photos = await this.db.getAll(STORE_NAME);\n      const photosToDelete = photos.filter(photo => {\n        const photoDate = new Date(photo.createdAt);\n        return photoDate < cutoffDate && photo.status === \"uploaded\";\n      });\n      for (const photo of photosToDelete) {\n        await this.db.delete(STORE_NAME, photo.id);\n      }\n      return photosToDelete.length;\n    } catch (error) {\n      console.error(\"Ошибка очистки старых фотографий:\", error);\n      return 0;\n    }\n  }\n}\nexport const photoService = new PhotoService();\nexport { PhotoService };","map":{"version":3,"names":["openDB","DB_NAME","DB_VERSION","STORE_NAME","PhotoService","constructor","db","initDB","upgrade","objectStoreNames","contains","createObjectStore","keyPath","error","console","savePhoto","photoData","arrayBuffer","file","photoToSave","fileData","fileType","type","fileName","name","put","getAllPhotos","photos","getAll","map","photo","File","updatePhotoStatus","photoId","status","get","deletePhoto","delete","uploadPhoto","id","formData","FormData","append","createdAt","apiUrl","fetch","method","response","body","ok","Error","result","json","url","uploadedAt","Date","toISOString","serverResponse","message","cleanupOldPhotos","daysOld","cutoffDate","setDate","getDate","photosToDelete","filter","photoDate","length","photoService"],"sources":["/Users/tigrotigro/Projects/Hakaton/PWA example/src/services/PhotoService.js"],"sourcesContent":["import { openDB } from \"idb\";\n\nconst DB_NAME = \"PhotoPWA\";\nconst DB_VERSION = 1;\nconst STORE_NAME = \"photos\";\n\nclass PhotoService {\n  constructor() {\n    this.db = null;\n    this.initDB();\n  }\n\n  async initDB() {\n    try {\n      this.db = await openDB(DB_NAME, DB_VERSION, {\n        upgrade(db) {\n          if (!db.objectStoreNames.contains(STORE_NAME)) {\n            db.createObjectStore(STORE_NAME, { keyPath: \"id\" });\n          }\n        },\n      });\n    } catch (error) {\n      console.error(\"Ошибка инициализации IndexedDB:\", error);\n    }\n  }\n\n  async savePhoto(photoData) {\n    try {\n      if (!this.db) await this.initDB();\n\n      // Конвертируем File в ArrayBuffer для хранения\n      const arrayBuffer = await photoData.file.arrayBuffer();\n      const photoToSave = {\n        ...photoData,\n        fileData: arrayBuffer,\n        fileType: photoData.file.type,\n        fileName: photoData.file.name,\n      };\n\n      // Удаляем оригинальный File объект\n      delete photoToSave.file;\n\n      await this.db.put(STORE_NAME, photoToSave);\n      return photoToSave;\n    } catch (error) {\n      console.error(\"Ошибка сохранения фотографии:\", error);\n      throw error;\n    }\n  }\n\n  async getAllPhotos() {\n    try {\n      if (!this.db) await this.initDB();\n\n      const photos = await this.db.getAll(STORE_NAME);\n\n      // Восстанавливаем File объекты из ArrayBuffer\n      return photos.map((photo) => {\n        if (photo.fileData) {\n          const file = new File([photo.fileData], photo.fileName, {\n            type: photo.fileType,\n          });\n          return {\n            ...photo,\n            file: file,\n          };\n        }\n        return photo;\n      });\n    } catch (error) {\n      console.error(\"Ошибка загрузки фотографий:\", error);\n      return [];\n    }\n  }\n\n  async updatePhotoStatus(photoId, status, error = null) {\n    try {\n      if (!this.db) {\n        await this.initDB();\n      }\n\n      const photo = await this.db.get(STORE_NAME, photoId);\n      if (photo) {\n        photo.status = status;\n        if (error) {\n          photo.error = error;\n        }\n        await this.db.put(STORE_NAME, photo);\n      }\n    } catch (error) {\n      console.error(\"Ошибка обновления статуса фотографии:\", error);\n    }\n  }\n\n  async deletePhoto(photoId) {\n    try {\n      if (!this.db) {\n        await this.initDB();\n      }\n      await this.db.delete(STORE_NAME, photoId);\n    } catch (error) {\n      console.error(\"Ошибка удаления фотографии:\", error);\n    }\n  }\n\n  async uploadPhoto(photoData) {\n    try {\n      // Обновляем статус на \"загрузка\"\n      await this.updatePhotoStatus(photoData.id, \"uploading\");\n\n      // Создаем FormData для отправки файла\n      const formData = new FormData();\n      formData.append(\"photo\", photoData.file);\n      formData.append(\"id\", photoData.id);\n      formData.append(\"name\", photoData.name);\n      formData.append(\"createdAt\", photoData.createdAt);\n\n      // Отправляем на локальный сервер\n      // Если сервер не запущен, используем httpbin.org для демонстрации\n      let apiUrl = \"http://localhost:3001/api/upload\";\n\n      // Проверяем, доступен ли локальный сервер\n      try {\n        await fetch(\"http://localhost:3001/api/files\", { method: \"HEAD\" });\n      } catch {\n        // Если локальный сервер недоступен, используем httpbin\n        apiUrl = \"https://httpbin.org/post\";\n      }\n\n      const response = await fetch(apiUrl, {\n        method: \"POST\",\n        body: formData,\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      const result = await response.json();\n\n      // Обновляем статус в базе данных\n      await this.updatePhotoStatus(photoData.id, \"uploaded\");\n\n      return {\n        id: photoData.id,\n        url: result.url || `https://example.com/photos/${photoData.id}.jpg`,\n        uploadedAt: new Date().toISOString(),\n        serverResponse: result,\n      };\n    } catch (error) {\n      console.error(\"Ошибка загрузки фотографии:\", error);\n\n      // Обновляем статус на ошибку\n      await this.updatePhotoStatus(photoData.id, \"error\", error.message);\n\n      throw error;\n    }\n  }\n\n  // Метод для очистки старых фотографий (опционально)\n  async cleanupOldPhotos(daysOld = 30) {\n    try {\n      if (!this.db) {\n        await this.initDB();\n      }\n\n      const cutoffDate = new Date();\n      cutoffDate.setDate(cutoffDate.getDate() - daysOld);\n\n      const photos = await this.db.getAll(STORE_NAME);\n      const photosToDelete = photos.filter((photo) => {\n        const photoDate = new Date(photo.createdAt);\n        return photoDate < cutoffDate && photo.status === \"uploaded\";\n      });\n\n      for (const photo of photosToDelete) {\n        await this.db.delete(STORE_NAME, photo.id);\n      }\n\n      return photosToDelete.length;\n    } catch (error) {\n      console.error(\"Ошибка очистки старых фотографий:\", error);\n      return 0;\n    }\n  }\n}\n\nexport const photoService = new PhotoService();\nexport { PhotoService };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}