{"ast":null,"code":"import { openDB } from \"idb\";\nimport config from \"../config.js\";\nconst DB_NAME = \"PhotoPWA\";\nconst DB_VERSION = 1;\nconst STORE_NAME = \"photos\";\nclass PhotoService {\n  constructor() {\n    this.db = null;\n    this.initDB();\n  }\n  async initDB() {\n    try {\n      this.db = await openDB(DB_NAME, DB_VERSION, {\n        upgrade(db) {\n          if (!db.objectStoreNames.contains(STORE_NAME)) {\n            db.createObjectStore(STORE_NAME, {\n              keyPath: \"id\"\n            });\n          }\n        }\n      });\n    } catch (error) {\n      console.error(\"Ошибка инициализации IndexedDB:\", error);\n    }\n  }\n  async savePhoto(photoData) {\n    try {\n      if (!this.db) await this.initDB();\n\n      // Конвертируем File в ArrayBuffer для хранения\n      const arrayBuffer = await photoData.file.arrayBuffer();\n      const photoToSave = {\n        ...photoData,\n        fileData: arrayBuffer,\n        fileType: photoData.file.type,\n        fileName: photoData.file.name\n      };\n\n      // Удаляем оригинальный File объект\n      delete photoToSave.file;\n      await this.db.put(STORE_NAME, photoToSave);\n      return photoToSave;\n    } catch (error) {\n      console.error(\"Ошибка сохранения фотографии:\", error);\n      throw error;\n    }\n  }\n  async getAllPhotos() {\n    try {\n      if (!this.db) await this.initDB();\n\n      // Получаем локальные фотографии из IndexedDB\n      const localPhotos = await this.db.getAll(STORE_NAME);\n\n      // Получаем серверные фотографии\n      const serverPhotos = await this.getServerPhotos();\n\n      // Создаем Set ID локальных фотографий для быстрой проверки\n      const localPhotoIds = new Set(localPhotos.map(p => p.id));\n\n      // Объединяем локальные и серверные фотографии\n      const allPhotos = [...localPhotos];\n\n      // Добавляем серверные фотографии, которых нет в локальной базе\n      for (const serverPhoto of serverPhotos) {\n        if (!localPhotoIds.has(serverPhoto.id)) {\n          allPhotos.push(serverPhoto);\n        }\n      }\n\n      // Восстанавливаем File объекты из ArrayBuffer и устанавливаем правильные URL\n      return allPhotos.map(photo => {\n        // Если фото загружено на сервер, используем серверный URL\n        if (photo.status === \"uploaded\" && photo.serverFilename) {\n          return {\n            ...photo,\n            url: `${config.API_URL}/uploads/${photo.serverFilename}`\n            // Не создаем File объект для загруженных фото, он не нужен\n          };\n        }\n\n        // Для серверных фото, которых нет в локальной базе\n        if (photo.url && photo.url.startsWith(`${config.API_URL}/uploads/`)) {\n          return photo;\n        }\n\n        // Для локальных фото создаем File объект\n        if (photo.fileData) {\n          const file = new File([photo.fileData], photo.fileName, {\n            type: photo.fileType\n          });\n          return {\n            ...photo,\n            file: file\n          };\n        }\n        return photo;\n      }).sort((a, b) => new Date(b.uploadedAt || b.createdAt) - new Date(a.uploadedAt || a.createdAt));\n    } catch (error) {\n      console.error(\"Ошибка загрузки фотографий:\", error);\n      return [];\n    }\n  }\n  async getServerPhotos() {\n    try {\n      const response = await fetch(`${config.API_URL}/api/files`);\n      if (!response.ok) {\n        // Если сервер недоступен, возвращаем пустой массив\n        console.warn(\"Сервер недоступен для загрузки фотографий\");\n        return [];\n      }\n      const data = await response.json();\n\n      // Преобразуем серверные файлы в формат, совместимый с нашими фотографиями\n      return data.files.map(file => ({\n        id: `server-${file.filename}`,\n        // Уникальный ID для серверных файлов\n        name: file.filename,\n        size: file.size,\n        status: \"uploaded\",\n        createdAt: file.uploadedAt,\n        uploadedAt: file.uploadedAt,\n        url: `${config.API_URL}${file.url}`,\n        serverFilename: file.filename,\n        isServerPhoto: true // Флаг для идентификации серверных фото\n      }));\n    } catch (error) {\n      console.warn(\"Ошибка загрузки серверных фотографий:\", error);\n      return [];\n    }\n  }\n  async updatePhotoStatus(photoId, status, error = null, serverFilename = null) {\n    try {\n      if (!this.db) {\n        await this.initDB();\n      }\n      const photo = await this.db.get(STORE_NAME, photoId);\n      if (photo) {\n        photo.status = status;\n        if (error) {\n          photo.error = error;\n        }\n        if (serverFilename) {\n          photo.serverFilename = serverFilename;\n        }\n        await this.db.put(STORE_NAME, photo);\n      }\n    } catch (error) {\n      console.error(\"Ошибка обновления статуса фотографии:\", error);\n    }\n  }\n  async deletePhoto(photoId) {\n    try {\n      if (!this.db) {\n        await this.initDB();\n      }\n\n      // Получаем информацию о фотографии перед удалением\n      const photo = await this.db.get(STORE_NAME, photoId);\n\n      // Удаляем файл с сервера, если он был загружен\n      if (photo && photo.serverFilename) {\n        try {\n          const response = await fetch(`${config.API_URL}/api/files/${photo.serverFilename}`, {\n            method: \"DELETE\"\n          });\n          if (!response.ok) {\n            console.warn(`Не удалось удалить файл с сервера: ${photo.serverFilename}`);\n          } else {\n            console.log(`Файл ${photo.serverFilename} успешно удален с сервера`);\n          }\n        } catch (serverError) {\n          console.warn(\"Ошибка при удалении файла с сервера:\", serverError);\n          // Продолжаем удаление из локальной БД даже если сервер недоступен\n        }\n      }\n\n      // Удаляем из локальной базы данных\n      await this.db.delete(STORE_NAME, photoId);\n    } catch (error) {\n      console.error(\"Ошибка удаления фотографии:\", error);\n      throw error;\n    }\n  }\n  async uploadPhoto(photoData) {\n    try {\n      var _result$file;\n      // Обновляем статус на \"загрузка\"\n      await this.updatePhotoStatus(photoData.id, \"uploading\");\n\n      // Создаем FormData для отправки файла\n      const formData = new FormData();\n      formData.append(\"photo\", photoData.file);\n      formData.append(\"id\", photoData.id);\n      formData.append(\"name\", photoData.name);\n      formData.append(\"createdAt\", photoData.createdAt);\n\n      // Отправляем на сервер\n      // Если сервер не запущен, используем httpbin.org для демонстрации\n      let apiUrl = `${config.API_URL}/api/upload`;\n\n      // Проверяем, доступен ли сервер\n      try {\n        await fetch(`${config.API_URL}/api/files`, {\n          method: \"HEAD\"\n        });\n      } catch {\n        // Если сервер недоступен, используем httpbin\n        apiUrl = \"https://httpbin.org/post\";\n      }\n      const response = await fetch(apiUrl, {\n        method: \"POST\",\n        body: formData\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const result = await response.json();\n\n      // Сохраняем имя файла на сервере для последующего удаления\n      const serverFilename = ((_result$file = result.file) === null || _result$file === void 0 ? void 0 : _result$file.filename) || null;\n      await this.updatePhotoStatus(photoData.id, \"uploaded\", null, serverFilename);\n      return {\n        id: photoData.id,\n        url: result.url || `https://example.com/photos/${photoData.id}.jpg`,\n        uploadedAt: new Date().toISOString(),\n        serverResponse: result,\n        serverFilename: serverFilename\n      };\n    } catch (error) {\n      console.error(\"Ошибка загрузки фотографии:\", error);\n\n      // Обновляем статус на ошибку\n      await this.updatePhotoStatus(photoData.id, \"error\", error.message);\n      throw error;\n    }\n  }\n\n  // Метод для очистки старых фотографий (опционально)\n  async cleanupOldPhotos(daysOld = 30) {\n    try {\n      if (!this.db) {\n        await this.initDB();\n      }\n      const cutoffDate = new Date();\n      cutoffDate.setDate(cutoffDate.getDate() - daysOld);\n      const photos = await this.db.getAll(STORE_NAME);\n      const photosToDelete = photos.filter(photo => {\n        const photoDate = new Date(photo.createdAt);\n        return photoDate < cutoffDate && photo.status === \"uploaded\";\n      });\n      for (const photo of photosToDelete) {\n        await this.db.delete(STORE_NAME, photo.id);\n      }\n      return photosToDelete.length;\n    } catch (error) {\n      console.error(\"Ошибка очистки старых фотографий:\", error);\n      return 0;\n    }\n  }\n}\nexport const photoService = new PhotoService();\nexport { PhotoService };","map":{"version":3,"names":["openDB","config","DB_NAME","DB_VERSION","STORE_NAME","PhotoService","constructor","db","initDB","upgrade","objectStoreNames","contains","createObjectStore","keyPath","error","console","savePhoto","photoData","arrayBuffer","file","photoToSave","fileData","fileType","type","fileName","name","put","getAllPhotos","localPhotos","getAll","serverPhotos","getServerPhotos","localPhotoIds","Set","map","p","id","allPhotos","serverPhoto","has","push","photo","status","serverFilename","url","API_URL","startsWith","File","sort","a","b","Date","uploadedAt","createdAt","response","fetch","ok","warn","data","json","files","filename","size","isServerPhoto","updatePhotoStatus","photoId","get","deletePhoto","method","log","serverError","delete","uploadPhoto","_result$file","formData","FormData","append","apiUrl","body","Error","result","toISOString","serverResponse","message","cleanupOldPhotos","daysOld","cutoffDate","setDate","getDate","photos","photosToDelete","filter","photoDate","length","photoService"],"sources":["/Users/tigrotigro/Projects/Hakaton/pwaexample/src/services/PhotoService.js"],"sourcesContent":["import { openDB } from \"idb\";\nimport config from \"../config.js\";\n\nconst DB_NAME = \"PhotoPWA\";\nconst DB_VERSION = 1;\nconst STORE_NAME = \"photos\";\n\nclass PhotoService {\n  constructor() {\n    this.db = null;\n    this.initDB();\n  }\n\n  async initDB() {\n    try {\n      this.db = await openDB(DB_NAME, DB_VERSION, {\n        upgrade(db) {\n          if (!db.objectStoreNames.contains(STORE_NAME)) {\n            db.createObjectStore(STORE_NAME, { keyPath: \"id\" });\n          }\n        },\n      });\n    } catch (error) {\n      console.error(\"Ошибка инициализации IndexedDB:\", error);\n    }\n  }\n\n  async savePhoto(photoData) {\n    try {\n      if (!this.db) await this.initDB();\n\n      // Конвертируем File в ArrayBuffer для хранения\n      const arrayBuffer = await photoData.file.arrayBuffer();\n      const photoToSave = {\n        ...photoData,\n        fileData: arrayBuffer,\n        fileType: photoData.file.type,\n        fileName: photoData.file.name,\n      };\n\n      // Удаляем оригинальный File объект\n      delete photoToSave.file;\n\n      await this.db.put(STORE_NAME, photoToSave);\n      return photoToSave;\n    } catch (error) {\n      console.error(\"Ошибка сохранения фотографии:\", error);\n      throw error;\n    }\n  }\n\n  async getAllPhotos() {\n    try {\n      if (!this.db) await this.initDB();\n\n      // Получаем локальные фотографии из IndexedDB\n      const localPhotos = await this.db.getAll(STORE_NAME);\n\n      // Получаем серверные фотографии\n      const serverPhotos = await this.getServerPhotos();\n\n      // Создаем Set ID локальных фотографий для быстрой проверки\n      const localPhotoIds = new Set(localPhotos.map((p) => p.id));\n\n      // Объединяем локальные и серверные фотографии\n      const allPhotos = [...localPhotos];\n\n      // Добавляем серверные фотографии, которых нет в локальной базе\n      for (const serverPhoto of serverPhotos) {\n        if (!localPhotoIds.has(serverPhoto.id)) {\n          allPhotos.push(serverPhoto);\n        }\n      }\n\n      // Восстанавливаем File объекты из ArrayBuffer и устанавливаем правильные URL\n      return allPhotos\n        .map((photo) => {\n          // Если фото загружено на сервер, используем серверный URL\n          if (photo.status === \"uploaded\" && photo.serverFilename) {\n            return {\n              ...photo,\n              url: `${config.API_URL}/uploads/${photo.serverFilename}`,\n              // Не создаем File объект для загруженных фото, он не нужен\n            };\n          }\n\n          // Для серверных фото, которых нет в локальной базе\n          if (photo.url && photo.url.startsWith(`${config.API_URL}/uploads/`)) {\n            return photo;\n          }\n\n          // Для локальных фото создаем File объект\n          if (photo.fileData) {\n            const file = new File([photo.fileData], photo.fileName, {\n              type: photo.fileType,\n            });\n            return {\n              ...photo,\n              file: file,\n            };\n          }\n\n          return photo;\n        })\n        .sort(\n          (a, b) =>\n            new Date(b.uploadedAt || b.createdAt) -\n            new Date(a.uploadedAt || a.createdAt)\n        );\n    } catch (error) {\n      console.error(\"Ошибка загрузки фотографий:\", error);\n      return [];\n    }\n  }\n\n  async getServerPhotos() {\n    try {\n      const response = await fetch(`${config.API_URL}/api/files`);\n      \n      if (!response.ok) {\n        // Если сервер недоступен, возвращаем пустой массив\n        console.warn(\"Сервер недоступен для загрузки фотографий\");\n        return [];\n      }\n\n      const data = await response.json();\n      \n      // Преобразуем серверные файлы в формат, совместимый с нашими фотографиями\n      return data.files.map(file => ({\n        id: `server-${file.filename}`, // Уникальный ID для серверных файлов\n        name: file.filename,\n        size: file.size,\n        status: \"uploaded\",\n        createdAt: file.uploadedAt,\n        uploadedAt: file.uploadedAt,\n        url: `${config.API_URL}${file.url}`,\n        serverFilename: file.filename,\n        isServerPhoto: true // Флаг для идентификации серверных фото\n      }));\n    } catch (error) {\n      console.warn(\"Ошибка загрузки серверных фотографий:\", error);\n      return [];\n    }\n  }\n\n  async updatePhotoStatus(\n    photoId,\n    status,\n    error = null,\n    serverFilename = null\n  ) {\n    try {\n      if (!this.db) {\n        await this.initDB();\n      }\n\n      const photo = await this.db.get(STORE_NAME, photoId);\n      if (photo) {\n        photo.status = status;\n        if (error) {\n          photo.error = error;\n        }\n        if (serverFilename) {\n          photo.serverFilename = serverFilename;\n        }\n        await this.db.put(STORE_NAME, photo);\n      }\n    } catch (error) {\n      console.error(\"Ошибка обновления статуса фотографии:\", error);\n    }\n  }\n\n  async deletePhoto(photoId) {\n    try {\n      if (!this.db) {\n        await this.initDB();\n      }\n\n      // Получаем информацию о фотографии перед удалением\n      const photo = await this.db.get(STORE_NAME, photoId);\n\n      // Удаляем файл с сервера, если он был загружен\n      if (photo && photo.serverFilename) {\n        try {\n          const response = await fetch(\n            `${config.API_URL}/api/files/${photo.serverFilename}`,\n            {\n              method: \"DELETE\",\n            }\n          );\n\n          if (!response.ok) {\n            console.warn(\n              `Не удалось удалить файл с сервера: ${photo.serverFilename}`\n            );\n          } else {\n            console.log(\n              `Файл ${photo.serverFilename} успешно удален с сервера`\n            );\n          }\n        } catch (serverError) {\n          console.warn(\"Ошибка при удалении файла с сервера:\", serverError);\n          // Продолжаем удаление из локальной БД даже если сервер недоступен\n        }\n      }\n\n      // Удаляем из локальной базы данных\n      await this.db.delete(STORE_NAME, photoId);\n    } catch (error) {\n      console.error(\"Ошибка удаления фотографии:\", error);\n      throw error;\n    }\n  }\n\n  async uploadPhoto(photoData) {\n    try {\n      // Обновляем статус на \"загрузка\"\n      await this.updatePhotoStatus(photoData.id, \"uploading\");\n\n      // Создаем FormData для отправки файла\n      const formData = new FormData();\n      formData.append(\"photo\", photoData.file);\n      formData.append(\"id\", photoData.id);\n      formData.append(\"name\", photoData.name);\n      formData.append(\"createdAt\", photoData.createdAt);\n\n      // Отправляем на сервер\n      // Если сервер не запущен, используем httpbin.org для демонстрации\n      let apiUrl = `${config.API_URL}/api/upload`;\n\n      // Проверяем, доступен ли сервер\n      try {\n        await fetch(`${config.API_URL}/api/files`, { method: \"HEAD\" });\n      } catch {\n        // Если сервер недоступен, используем httpbin\n        apiUrl = \"https://httpbin.org/post\";\n      }\n\n      const response = await fetch(apiUrl, {\n        method: \"POST\",\n        body: formData,\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      const result = await response.json();\n\n      // Сохраняем имя файла на сервере для последующего удаления\n      const serverFilename = result.file?.filename || null;\n      await this.updatePhotoStatus(\n        photoData.id,\n        \"uploaded\",\n        null,\n        serverFilename\n      );\n\n      return {\n        id: photoData.id,\n        url: result.url || `https://example.com/photos/${photoData.id}.jpg`,\n        uploadedAt: new Date().toISOString(),\n        serverResponse: result,\n        serverFilename: serverFilename,\n      };\n    } catch (error) {\n      console.error(\"Ошибка загрузки фотографии:\", error);\n\n      // Обновляем статус на ошибку\n      await this.updatePhotoStatus(photoData.id, \"error\", error.message);\n\n      throw error;\n    }\n  }\n\n  // Метод для очистки старых фотографий (опционально)\n  async cleanupOldPhotos(daysOld = 30) {\n    try {\n      if (!this.db) {\n        await this.initDB();\n      }\n\n      const cutoffDate = new Date();\n      cutoffDate.setDate(cutoffDate.getDate() - daysOld);\n\n      const photos = await this.db.getAll(STORE_NAME);\n      const photosToDelete = photos.filter((photo) => {\n        const photoDate = new Date(photo.createdAt);\n        return photoDate < cutoffDate && photo.status === \"uploaded\";\n      });\n\n      for (const photo of photosToDelete) {\n        await this.db.delete(STORE_NAME, photo.id);\n      }\n\n      return photosToDelete.length;\n    } catch (error) {\n      console.error(\"Ошибка очистки старых фотографий:\", error);\n      return 0;\n    }\n  }\n}\n\nexport const photoService = new PhotoService();\nexport { PhotoService };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}