{"ast":null,"code":"import { openDB } from \"idb\";\nimport config from \"../config\";\nconst DB_NAME = \"PhotoPWA\";\nconst DB_VERSION = 1;\nconst STORE_NAME = \"photos\";\nclass PhotoService {\n  constructor() {\n    this.db = null;\n    this.initDB();\n  }\n  async initDB() {\n    try {\n      this.db = await openDB(DB_NAME, DB_VERSION, {\n        upgrade(db) {\n          if (!db.objectStoreNames.contains(STORE_NAME)) {\n            db.createObjectStore(STORE_NAME, {\n              keyPath: \"id\"\n            });\n          }\n        }\n      });\n    } catch (error) {\n      console.error(\"Ошибка инициализации IndexedDB:\", error);\n    }\n  }\n  async savePhoto(photoData) {\n    try {\n      if (!this.db) await this.initDB();\n\n      // Конвертируем File в ArrayBuffer для хранения\n      const arrayBuffer = await photoData.file.arrayBuffer();\n      const photoToSave = {\n        ...photoData,\n        fileData: arrayBuffer,\n        fileType: photoData.file.type,\n        fileName: photoData.file.name\n      };\n\n      // Удаляем оригинальный File объект\n      delete photoToSave.file;\n      await this.db.put(STORE_NAME, photoToSave);\n      return photoToSave;\n    } catch (error) {\n      console.error(\"Ошибка сохранения фотографии:\", error);\n      throw error;\n    }\n  }\n  async getAllPhotos() {\n    try {\n      if (!this.db) await this.initDB();\n\n      // Получаем локальные фотографии из IndexedDB\n      const localPhotos = await this.db.getAll(STORE_NAME);\n\n      // Получаем серверные фотографии (только если онлайн)\n      let serverPhotos = [];\n      try {\n        if (navigator.onLine) {\n          serverPhotos = await this.loadPhotosFromServer();\n        }\n      } catch (error) {\n        console.warn(\"Не удалось загрузить серверные фото:\", error);\n        serverPhotos = [];\n      }\n\n      // Создаем Set ID локальных фотографий для быстрой проверки\n      const localPhotoIds = new Set(localPhotos.map(p => p.id));\n\n      // Объединяем локальные и серверные фотографии\n      const allPhotos = [...localPhotos];\n\n      // Добавляем серверные фотографии, которых нет в локальной базе\n      for (const serverPhoto of serverPhotos) {\n        if (!localPhotoIds.has(serverPhoto.id)) {\n          allPhotos.push(serverPhoto);\n        }\n      }\n\n      // Восстанавливаем File объекты из ArrayBuffer и устанавливаем правильные URL\n      return allPhotos.map(photo => {\n        // Если фото загружено на сервер, используем серверный URL\n        if (photo.status === \"uploaded\" && photo.serverFilename) {\n          return {\n            ...photo,\n            url: `${config.API_URL}/uploads/${photo.serverFilename}`\n            // Не создаем File объект для загруженных фото, он не нужен\n          };\n        }\n\n        // Для серверных фото, которых нет в локальной базе\n        if (photo.url && photo.url.startsWith(`${config.API_URL}/uploads/`)) {\n          return photo;\n        }\n\n        // Для локальных фото создаем File объект\n        if (photo.fileData) {\n          const file = new File([photo.fileData], photo.fileName, {\n            type: photo.fileType\n          });\n          return {\n            ...photo,\n            file: file\n          };\n        }\n        return photo;\n      }).sort((a, b) => new Date(b.uploadedAt || b.createdAt) - new Date(a.uploadedAt || a.createdAt));\n    } catch (error) {\n      console.error(\"Ошибка загрузки фотографий:\", error);\n      return [];\n    }\n  }\n  async getServerPhotos() {\n    try {\n      const response = await fetch(`${config.API_URL}/api/files`);\n      if (!response.ok) {\n        // Если сервер недоступен, возвращаем пустой массив\n        console.warn(\"Сервер недоступен для загрузки фотографий\");\n        return [];\n      }\n      const data = await response.json();\n      console.log(config);\n      console.log(response.json());\n\n      // Преобразуем серверные файлы в формат, совместимый с нашими фотографиями\n      return data.files.map(file => ({\n        id: `server-${file.filename}`,\n        // Уникальный ID для серверных файлов\n        name: file.filename,\n        size: file.size,\n        status: \"uploaded\",\n        createdAt: file.uploadedAt,\n        uploadedAt: file.uploadedAt,\n        url: `${config.API_URL}${file.url}`,\n        serverFilename: file.filename,\n        isServerPhoto: true // Флаг для идентификации серверных фото\n      }));\n    } catch (error) {\n      console.warn(\"Ошибка загрузки серверных фотографий:\", error);\n      return [];\n    }\n  }\n  async updatePhotoStatus(photoId, status, error = null, serverFilename = null) {\n    try {\n      if (!this.db) {\n        await this.initDB();\n      }\n      const photo = await this.db.get(STORE_NAME, photoId);\n      if (photo) {\n        photo.status = status;\n        if (error) {\n          photo.error = error;\n        }\n        if (serverFilename) {\n          photo.serverFilename = serverFilename;\n        }\n        await this.db.put(STORE_NAME, photo);\n      }\n    } catch (error) {\n      console.error(\"Ошибка обновления статуса фотографии:\", error);\n    }\n  }\n  async deletePhoto(photoId) {\n    try {\n      if (!this.db) {\n        await this.initDB();\n      }\n\n      // Проверяем, является ли это серверной фотографией\n      if (photoId.startsWith(\"server-\")) {\n        // Для серверных фотографий удаляем только с сервера\n        const serverFilename = photoId.replace(\"server-\", \"\");\n        try {\n          const response = await fetch(`${config.API_URL}/api/files/${serverFilename}`, {\n            method: \"DELETE\"\n          });\n          if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n          }\n          console.log(`Файл ${serverFilename} успешно удален с сервера`);\n        } catch (serverError) {\n          console.error(\"Ошибка при удалении файла с сервера:\", serverError);\n          throw serverError;\n        }\n        return;\n      }\n\n      // Получаем информацию о локальной фотографии перед удалением\n      const photo = await this.db.get(STORE_NAME, photoId);\n\n      // Удаляем файл с сервера, если он был загружен\n      if (photo && photo.serverFilename) {\n        try {\n          const response = await fetch(`${config.API_URL}/api/files/${photo.serverFilename}`, {\n            method: \"DELETE\"\n          });\n          if (!response.ok) {\n            console.warn(`Не удалось удалить файл с сервера: ${photo.serverFilename}`);\n          } else {\n            console.log(`Файл ${photo.serverFilename} успешно удален с сервера`);\n          }\n        } catch (serverError) {\n          console.warn(\"Ошибка при удалении файла с сервера:\", serverError);\n          // Продолжаем удаление из локальной БД даже если сервер недоступен\n        }\n      }\n\n      // Удаляем из локальной базы данных\n      await this.db.delete(STORE_NAME, photoId);\n    } catch (error) {\n      console.error(\"Ошибка удаления фотографии:\", error);\n      throw error;\n    }\n  }\n  async uploadPhoto(photoData) {\n    try {\n      var _result$file;\n      // Обновляем статус на \"загрузка\"\n      await this.updatePhotoStatus(photoData.id, \"uploading\");\n\n      // Создаем FormData для отправки файла\n      const formData = new FormData();\n      formData.append(\"photo\", photoData.file);\n      formData.append(\"id\", photoData.id);\n      formData.append(\"name\", photoData.name);\n      formData.append(\"createdAt\", photoData.createdAt);\n\n      // Отправляем на сервер\n      // Если сервер не запущен, используем httpbin.org для демонстрации\n      let apiUrl = `${config.API_URL}/api/upload`;\n\n      // Проверяем, доступен ли сервер\n      try {\n        await fetch(`${config.API_URL}/api/files`, {\n          method: \"HEAD\"\n        });\n      } catch {\n        // Если сервер недоступен, используем httpbin\n        apiUrl = \"https://httpbin.org/post\";\n      }\n      const response = await fetch(apiUrl, {\n        method: \"POST\",\n        body: formData\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const result = await response.json();\n\n      // Сохраняем имя файла на сервере для последующего удаления\n      const serverFilename = ((_result$file = result.file) === null || _result$file === void 0 ? void 0 : _result$file.filename) || null;\n      await this.updatePhotoStatus(photoData.id, \"uploaded\", null, serverFilename);\n      return {\n        id: photoData.id,\n        url: result.url || `https://example.com/photos/${photoData.id}.jpg`,\n        uploadedAt: new Date().toISOString(),\n        serverResponse: result,\n        serverFilename: serverFilename\n      };\n    } catch (error) {\n      console.error(\"Ошибка загрузки фотографии:\", error);\n\n      // Обновляем статус на ошибку\n      await this.updatePhotoStatus(photoData.id, \"error\", error.message);\n      throw error;\n    }\n  }\n\n  // Загружает список фотографий с сервера\n  async loadPhotosFromServer() {\n    try {\n      const apiUrl = `${config.API_URL}/api/files`;\n      console.log(\"Загружаем фотографии с сервера:\", apiUrl);\n      const response = await fetch(apiUrl, {\n        method: \"GET\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        }\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      const serverPhotos = data.files || [];\n      console.log(`Найдено ${serverPhotos.length} фотографий на сервере`);\n\n      // Преобразуем серверные фотографии в формат приложения\n      const transformedPhotos = serverPhotos.map(serverPhoto => ({\n        id: `server_${serverPhoto.filename}`,\n        // Уникальный ID для серверных фото\n        name: serverPhoto.filename,\n        size: serverPhoto.size,\n        status: \"uploaded\",\n        createdAt: serverPhoto.uploadedAt,\n        serverFilename: serverPhoto.filename,\n        url: `${config.API_URL}${serverPhoto.url}`,\n        isFromServer: true // Флаг что это фото с сервера\n      }));\n      return transformedPhotos;\n    } catch (error) {\n      console.error(\"Ошибка загрузки фотографий с сервера:\", error);\n      return [];\n    }\n  }\n\n  // Синхронизирует локальные фото с серверными\n  async syncWithServer(forceReload = false) {\n    try {\n      if (!this.db) await this.initDB();\n\n      // Загружаем фотографии с сервера\n      const serverPhotos = await this.loadPhotosFromServer();\n\n      // Получаем локальные фотографии\n      const localPhotos = await this.db.getAll(STORE_NAME);\n\n      // Создаем Set из имен файлов на сервере для быстрого поиска\n      const serverFilenames = new Set(serverPhotos.map(photo => photo.serverFilename));\n\n      // Обновляем статус локальных фото, которые есть на сервере\n      for (const localPhoto of localPhotos) {\n        if (localPhoto.serverFilename && serverFilenames.has(localPhoto.serverFilename)) {\n          if (localPhoto.status !== \"uploaded\") {\n            localPhoto.status = \"uploaded\";\n            await this.db.put(STORE_NAME, localPhoto);\n          }\n        }\n      }\n\n      // Добавляем серверные фото, которых нет в локальной базе\n      const localServerFilenames = new Set(localPhotos.filter(photo => photo.serverFilename).map(photo => photo.serverFilename));\n      for (const serverPhoto of serverPhotos) {\n        if (!localServerFilenames.has(serverPhoto.serverFilename) || forceReload) {\n          // Сохраняем серверное фото в локальную базу\n          // При forceReload обновляем даже существующие серверные фото\n          await this.db.put(STORE_NAME, serverPhoto);\n          if (forceReload) {\n            console.log(`🔄 Обновлено серверное фото: ${serverPhoto.name}`);\n          }\n        }\n      }\n      console.log(\"Синхронизация с сервером завершена\");\n      return true;\n    } catch (error) {\n      console.error(\"Ошибка синхронизации с сервером:\", error);\n      return false;\n    }\n  }\n\n  // Получает все фотографии с учетом синхронизации с сервером\n  async getAllPhotosWithSync() {\n    try {\n      console.log(\"🔄 Начинаем синхронизацию с сервером...\");\n\n      // Получаем локальные фото до синхронизации\n      const localPhotosBeforeSync = await this.getAllPhotos();\n      console.log(`📱 Локальных фото до синхронизации: ${localPhotosBeforeSync.length}`);\n\n      // Синхронизируемся с сервером\n      await this.syncWithServer();\n\n      // Получаем все фотографии после синхронизации\n      const allPhotosAfterSync = await this.getAllPhotos();\n      console.log(`📊 Всего фото после синхронизации: ${allPhotosAfterSync.length}`);\n      const serverPhotos = allPhotosAfterSync.filter(photo => photo.isFromServer);\n      const localPhotos = allPhotosAfterSync.filter(photo => !photo.isFromServer);\n      console.log(`🌐 Серверных фото: ${serverPhotos.length}`);\n      console.log(`📱 Локальных фото: ${localPhotos.length}`);\n      console.log(\"✅ Синхронизация завершена успешно!\");\n      return allPhotosAfterSync;\n    } catch (error) {\n      console.error(\"❌ Ошибка получения фотографий с синхронизацией:\", error);\n      // Если синхронизация не удалась, возвращаем только локальные фото\n      const localPhotos = await this.getAllPhotos();\n      console.log(`📱 Возвращаем только локальные фото: ${localPhotos.length}`);\n      return localPhotos;\n    }\n  }\n\n  // Метод для очистки старых фотографий (опционально)\n  async cleanupOldPhotos(daysOld = 30) {\n    try {\n      if (!this.db) {\n        await this.initDB();\n      }\n      const cutoffDate = new Date();\n      cutoffDate.setDate(cutoffDate.getDate() - daysOld);\n      const photos = await this.db.getAll(STORE_NAME);\n      const photosToDelete = photos.filter(photo => {\n        const photoDate = new Date(photo.createdAt);\n        return photoDate < cutoffDate && photo.status === \"uploaded\";\n      });\n      for (const photo of photosToDelete) {\n        await this.db.delete(STORE_NAME, photo.id);\n      }\n      return photosToDelete.length;\n    } catch (error) {\n      console.error(\"Ошибка очистки старых фотографий:\", error);\n      return 0;\n    }\n  }\n}\nexport const photoService = new PhotoService();\nexport { PhotoService };","map":{"version":3,"names":["openDB","config","DB_NAME","DB_VERSION","STORE_NAME","PhotoService","constructor","db","initDB","upgrade","objectStoreNames","contains","createObjectStore","keyPath","error","console","savePhoto","photoData","arrayBuffer","file","photoToSave","fileData","fileType","type","fileName","name","put","getAllPhotos","localPhotos","getAll","serverPhotos","navigator","onLine","loadPhotosFromServer","warn","localPhotoIds","Set","map","p","id","allPhotos","serverPhoto","has","push","photo","status","serverFilename","url","API_URL","startsWith","File","sort","a","b","Date","uploadedAt","createdAt","getServerPhotos","response","fetch","ok","data","json","log","files","filename","size","isServerPhoto","updatePhotoStatus","photoId","get","deletePhoto","replace","method","Error","serverError","delete","uploadPhoto","_result$file","formData","FormData","append","apiUrl","body","result","toISOString","serverResponse","message","headers","length","transformedPhotos","isFromServer","syncWithServer","forceReload","serverFilenames","localPhoto","localServerFilenames","filter","getAllPhotosWithSync","localPhotosBeforeSync","allPhotosAfterSync","cleanupOldPhotos","daysOld","cutoffDate","setDate","getDate","photos","photosToDelete","photoDate","photoService"],"sources":["/Users/tigrotigro/Projects/Hakaton/pwaexample/src/services/PhotoService.js"],"sourcesContent":["import { openDB } from \"idb\";\nimport config from \"../config\";\n\nconst DB_NAME = \"PhotoPWA\";\nconst DB_VERSION = 1;\nconst STORE_NAME = \"photos\";\n\nclass PhotoService {\n  constructor() {\n    this.db = null;\n    this.initDB();\n  }\n\n  async initDB() {\n    try {\n      this.db = await openDB(DB_NAME, DB_VERSION, {\n        upgrade(db) {\n          if (!db.objectStoreNames.contains(STORE_NAME)) {\n            db.createObjectStore(STORE_NAME, { keyPath: \"id\" });\n          }\n        },\n      });\n    } catch (error) {\n      console.error(\"Ошибка инициализации IndexedDB:\", error);\n    }\n  }\n\n  async savePhoto(photoData) {\n    try {\n      if (!this.db) await this.initDB();\n\n      // Конвертируем File в ArrayBuffer для хранения\n      const arrayBuffer = await photoData.file.arrayBuffer();\n      const photoToSave = {\n        ...photoData,\n        fileData: arrayBuffer,\n        fileType: photoData.file.type,\n        fileName: photoData.file.name,\n      };\n\n      // Удаляем оригинальный File объект\n      delete photoToSave.file;\n\n      await this.db.put(STORE_NAME, photoToSave);\n      return photoToSave;\n    } catch (error) {\n      console.error(\"Ошибка сохранения фотографии:\", error);\n      throw error;\n    }\n  }\n\n  async getAllPhotos() {\n    try {\n      if (!this.db) await this.initDB();\n\n      // Получаем локальные фотографии из IndexedDB\n      const localPhotos = await this.db.getAll(STORE_NAME);\n\n      // Получаем серверные фотографии (только если онлайн)\n      let serverPhotos = [];\n      try {\n        if (navigator.onLine) {\n          serverPhotos = await this.loadPhotosFromServer();\n        }\n      } catch (error) {\n        console.warn(\"Не удалось загрузить серверные фото:\", error);\n        serverPhotos = [];\n      }\n\n      // Создаем Set ID локальных фотографий для быстрой проверки\n      const localPhotoIds = new Set(localPhotos.map((p) => p.id));\n\n      // Объединяем локальные и серверные фотографии\n      const allPhotos = [...localPhotos];\n\n      // Добавляем серверные фотографии, которых нет в локальной базе\n      for (const serverPhoto of serverPhotos) {\n        if (!localPhotoIds.has(serverPhoto.id)) {\n          allPhotos.push(serverPhoto);\n        }\n      }\n\n      // Восстанавливаем File объекты из ArrayBuffer и устанавливаем правильные URL\n      return allPhotos\n        .map((photo) => {\n          // Если фото загружено на сервер, используем серверный URL\n          if (photo.status === \"uploaded\" && photo.serverFilename) {\n            return {\n              ...photo,\n              url: `${config.API_URL}/uploads/${photo.serverFilename}`,\n              // Не создаем File объект для загруженных фото, он не нужен\n            };\n          }\n\n          // Для серверных фото, которых нет в локальной базе\n          if (photo.url && photo.url.startsWith(`${config.API_URL}/uploads/`)) {\n            return photo;\n          }\n\n          // Для локальных фото создаем File объект\n          if (photo.fileData) {\n            const file = new File([photo.fileData], photo.fileName, {\n              type: photo.fileType,\n            });\n            return {\n              ...photo,\n              file: file,\n            };\n          }\n\n          return photo;\n        })\n        .sort(\n          (a, b) =>\n            new Date(b.uploadedAt || b.createdAt) -\n            new Date(a.uploadedAt || a.createdAt)\n        );\n    } catch (error) {\n      console.error(\"Ошибка загрузки фотографий:\", error);\n      return [];\n    }\n  }\n\n  async getServerPhotos() {\n    try {\n      const response = await fetch(`${config.API_URL}/api/files`);\n\n      if (!response.ok) {\n        // Если сервер недоступен, возвращаем пустой массив\n        console.warn(\"Сервер недоступен для загрузки фотографий\");\n        return [];\n      }\n\n      const data = await response.json();\n      console.log(config);\n      console.log(response.json());\n\n      // Преобразуем серверные файлы в формат, совместимый с нашими фотографиями\n      return data.files.map((file) => ({\n        id: `server-${file.filename}`, // Уникальный ID для серверных файлов\n        name: file.filename,\n        size: file.size,\n        status: \"uploaded\",\n        createdAt: file.uploadedAt,\n        uploadedAt: file.uploadedAt,\n        url: `${config.API_URL}${file.url}`,\n        serverFilename: file.filename,\n        isServerPhoto: true, // Флаг для идентификации серверных фото\n      }));\n    } catch (error) {\n      console.warn(\"Ошибка загрузки серверных фотографий:\", error);\n      return [];\n    }\n  }\n\n  async updatePhotoStatus(\n    photoId,\n    status,\n    error = null,\n    serverFilename = null\n  ) {\n    try {\n      if (!this.db) {\n        await this.initDB();\n      }\n\n      const photo = await this.db.get(STORE_NAME, photoId);\n      if (photo) {\n        photo.status = status;\n        if (error) {\n          photo.error = error;\n        }\n        if (serverFilename) {\n          photo.serverFilename = serverFilename;\n        }\n        await this.db.put(STORE_NAME, photo);\n      }\n    } catch (error) {\n      console.error(\"Ошибка обновления статуса фотографии:\", error);\n    }\n  }\n\n  async deletePhoto(photoId) {\n    try {\n      if (!this.db) {\n        await this.initDB();\n      }\n\n      // Проверяем, является ли это серверной фотографией\n      if (photoId.startsWith(\"server-\")) {\n        // Для серверных фотографий удаляем только с сервера\n        const serverFilename = photoId.replace(\"server-\", \"\");\n        try {\n          const response = await fetch(\n            `${config.API_URL}/api/files/${serverFilename}`,\n            {\n              method: \"DELETE\",\n            }\n          );\n\n          if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n          }\n\n          console.log(`Файл ${serverFilename} успешно удален с сервера`);\n        } catch (serverError) {\n          console.error(\"Ошибка при удалении файла с сервера:\", serverError);\n          throw serverError;\n        }\n        return;\n      }\n\n      // Получаем информацию о локальной фотографии перед удалением\n      const photo = await this.db.get(STORE_NAME, photoId);\n\n      // Удаляем файл с сервера, если он был загружен\n      if (photo && photo.serverFilename) {\n        try {\n          const response = await fetch(\n            `${config.API_URL}/api/files/${photo.serverFilename}`,\n            {\n              method: \"DELETE\",\n            }\n          );\n\n          if (!response.ok) {\n            console.warn(\n              `Не удалось удалить файл с сервера: ${photo.serverFilename}`\n            );\n          } else {\n            console.log(\n              `Файл ${photo.serverFilename} успешно удален с сервера`\n            );\n          }\n        } catch (serverError) {\n          console.warn(\"Ошибка при удалении файла с сервера:\", serverError);\n          // Продолжаем удаление из локальной БД даже если сервер недоступен\n        }\n      }\n\n      // Удаляем из локальной базы данных\n      await this.db.delete(STORE_NAME, photoId);\n    } catch (error) {\n      console.error(\"Ошибка удаления фотографии:\", error);\n      throw error;\n    }\n  }\n\n  async uploadPhoto(photoData) {\n    try {\n      // Обновляем статус на \"загрузка\"\n      await this.updatePhotoStatus(photoData.id, \"uploading\");\n\n      // Создаем FormData для отправки файла\n      const formData = new FormData();\n      formData.append(\"photo\", photoData.file);\n      formData.append(\"id\", photoData.id);\n      formData.append(\"name\", photoData.name);\n      formData.append(\"createdAt\", photoData.createdAt);\n\n      // Отправляем на сервер\n      // Если сервер не запущен, используем httpbin.org для демонстрации\n      let apiUrl = `${config.API_URL}/api/upload`;\n\n      // Проверяем, доступен ли сервер\n      try {\n        await fetch(`${config.API_URL}/api/files`, { method: \"HEAD\" });\n      } catch {\n        // Если сервер недоступен, используем httpbin\n        apiUrl = \"https://httpbin.org/post\";\n      }\n\n      const response = await fetch(apiUrl, {\n        method: \"POST\",\n        body: formData,\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      const result = await response.json();\n\n      // Сохраняем имя файла на сервере для последующего удаления\n      const serverFilename = result.file?.filename || null;\n      await this.updatePhotoStatus(\n        photoData.id,\n        \"uploaded\",\n        null,\n        serverFilename\n      );\n\n      return {\n        id: photoData.id,\n        url: result.url || `https://example.com/photos/${photoData.id}.jpg`,\n        uploadedAt: new Date().toISOString(),\n        serverResponse: result,\n        serverFilename: serverFilename,\n      };\n    } catch (error) {\n      console.error(\"Ошибка загрузки фотографии:\", error);\n\n      // Обновляем статус на ошибку\n      await this.updatePhotoStatus(photoData.id, \"error\", error.message);\n\n      throw error;\n    }\n  }\n\n  // Загружает список фотографий с сервера\n  async loadPhotosFromServer() {\n    try {\n      const apiUrl = `${config.API_URL}/api/files`;\n      console.log(\"Загружаем фотографии с сервера:\", apiUrl);\n\n      const response = await fetch(apiUrl, {\n        method: \"GET\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      const data = await response.json();\n      const serverPhotos = data.files || [];\n\n      console.log(`Найдено ${serverPhotos.length} фотографий на сервере`);\n\n      // Преобразуем серверные фотографии в формат приложения\n      const transformedPhotos = serverPhotos.map((serverPhoto) => ({\n        id: `server_${serverPhoto.filename}`, // Уникальный ID для серверных фото\n        name: serverPhoto.filename,\n        size: serverPhoto.size,\n        status: \"uploaded\",\n        createdAt: serverPhoto.uploadedAt,\n        serverFilename: serverPhoto.filename,\n        url: `${config.API_URL}${serverPhoto.url}`,\n        isFromServer: true, // Флаг что это фото с сервера\n      }));\n\n      return transformedPhotos;\n    } catch (error) {\n      console.error(\"Ошибка загрузки фотографий с сервера:\", error);\n      return [];\n    }\n  }\n\n  // Синхронизирует локальные фото с серверными\n  async syncWithServer(forceReload = false) {\n    try {\n      if (!this.db) await this.initDB();\n\n      // Загружаем фотографии с сервера\n      const serverPhotos = await this.loadPhotosFromServer();\n\n      // Получаем локальные фотографии\n      const localPhotos = await this.db.getAll(STORE_NAME);\n\n      // Создаем Set из имен файлов на сервере для быстрого поиска\n      const serverFilenames = new Set(\n        serverPhotos.map((photo) => photo.serverFilename)\n      );\n\n      // Обновляем статус локальных фото, которые есть на сервере\n      for (const localPhoto of localPhotos) {\n        if (\n          localPhoto.serverFilename &&\n          serverFilenames.has(localPhoto.serverFilename)\n        ) {\n          if (localPhoto.status !== \"uploaded\") {\n            localPhoto.status = \"uploaded\";\n            await this.db.put(STORE_NAME, localPhoto);\n          }\n        }\n      }\n\n      // Добавляем серверные фото, которых нет в локальной базе\n      const localServerFilenames = new Set(\n        localPhotos\n          .filter((photo) => photo.serverFilename)\n          .map((photo) => photo.serverFilename)\n      );\n\n      for (const serverPhoto of serverPhotos) {\n        if (\n          !localServerFilenames.has(serverPhoto.serverFilename) ||\n          forceReload\n        ) {\n          // Сохраняем серверное фото в локальную базу\n          // При forceReload обновляем даже существующие серверные фото\n          await this.db.put(STORE_NAME, serverPhoto);\n          if (forceReload) {\n            console.log(`🔄 Обновлено серверное фото: ${serverPhoto.name}`);\n          }\n        }\n      }\n\n      console.log(\"Синхронизация с сервером завершена\");\n      return true;\n    } catch (error) {\n      console.error(\"Ошибка синхронизации с сервером:\", error);\n      return false;\n    }\n  }\n\n  // Получает все фотографии с учетом синхронизации с сервером\n  async getAllPhotosWithSync() {\n    try {\n      console.log(\"🔄 Начинаем синхронизацию с сервером...\");\n\n      // Получаем локальные фото до синхронизации\n      const localPhotosBeforeSync = await this.getAllPhotos();\n      console.log(\n        `📱 Локальных фото до синхронизации: ${localPhotosBeforeSync.length}`\n      );\n\n      // Синхронизируемся с сервером\n      await this.syncWithServer();\n\n      // Получаем все фотографии после синхронизации\n      const allPhotosAfterSync = await this.getAllPhotos();\n      console.log(\n        `📊 Всего фото после синхронизации: ${allPhotosAfterSync.length}`\n      );\n\n      const serverPhotos = allPhotosAfterSync.filter(\n        (photo) => photo.isFromServer\n      );\n      const localPhotos = allPhotosAfterSync.filter(\n        (photo) => !photo.isFromServer\n      );\n\n      console.log(`🌐 Серверных фото: ${serverPhotos.length}`);\n      console.log(`📱 Локальных фото: ${localPhotos.length}`);\n      console.log(\"✅ Синхронизация завершена успешно!\");\n\n      return allPhotosAfterSync;\n    } catch (error) {\n      console.error(\"❌ Ошибка получения фотографий с синхронизацией:\", error);\n      // Если синхронизация не удалась, возвращаем только локальные фото\n      const localPhotos = await this.getAllPhotos();\n      console.log(`📱 Возвращаем только локальные фото: ${localPhotos.length}`);\n      return localPhotos;\n    }\n  }\n\n  // Метод для очистки старых фотографий (опционально)\n  async cleanupOldPhotos(daysOld = 30) {\n    try {\n      if (!this.db) {\n        await this.initDB();\n      }\n\n      const cutoffDate = new Date();\n      cutoffDate.setDate(cutoffDate.getDate() - daysOld);\n\n      const photos = await this.db.getAll(STORE_NAME);\n      const photosToDelete = photos.filter((photo) => {\n        const photoDate = new Date(photo.createdAt);\n        return photoDate < cutoffDate && photo.status === \"uploaded\";\n      });\n\n      for (const photo of photosToDelete) {\n        await this.db.delete(STORE_NAME, photo.id);\n      }\n\n      return photosToDelete.length;\n    } catch (error) {\n      console.error(\"Ошибка очистки старых фотографий:\", error);\n      return 0;\n    }\n  }\n}\n\nexport const photoService = new PhotoService();\nexport { PhotoService };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}